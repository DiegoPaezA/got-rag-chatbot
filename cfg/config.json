{
  "llm_settings": {
    "model_name": "gemini-2.5-flash-preview-09-2025",
    "temperature": 0.0,
    "max_retries": 3
  },
  "embedding_settings": {
    "provider": "google", 
    "model_name": "models/text-embedding-004",
    "device": "cpu",
    "chunk_size": 1000, 
    "chunk_overlap": 200,
    "separators": ["\n\n", "\n", ". ", " ", ""] 
  },
  "graph_settings": {
    "allowed_types": [
      "Character", "House", "Organization", "Battle",
      "Location", "Object", "Creature", "Religion",
      "Episode", "Lore"
    ]
  },
  "prompts": {
    "validator_system": "You are an expert Data Architect for a 'Game of Thrones' Knowledge Graph.\nYour task is to clean and validate a database of entities.\n\nYou will be given a LIST of entities in JSON format. For each entity, you must:\n- Decide the CORRECT type according to the ontology.\n- Copy the 'id' field EXACTLY as given.\n- Provide a confidence level and a short rationale.\n\nAllowed ontology (use EXACTLY these labels for 'suggested_type'):\n{allowed_types}\n\nValidation rules and hints:\n1. Characters:\n   - If context mentions 'played by', 'actor', 'father', 'mother', 'born', or 'died',\n     the entity is almost certainly a 'Character' (even if it also looks like an Organization/Object).\n2. Lore vs Character:\n   - Real-world people (directors, producers, stuntman, etc.) are usually 'Lore' or possibly 'Character'\n     if they exist in-universe. If they are purely production staff and not part of the GoT universe,\n     prefer 'Lore'.\n3. Battles:\n   - Entities that are wars, sieges, sacks, or named conflicts should be 'Battle'.\n4. Objects:\n   - Swords, blades, ships, poisons, crowns, artifacts, etc. should be 'Object'.\n5. Organizations:\n   - Guilds, banks, religious orders, guards, brotherhoods, watches, councils, etc. should be 'Organization'.\n6. Locations:\n   - Castles, cities, regions, islands, rivers, etc. should be 'Location'.\n7. Episodes:\n   - TV episodes (with directors, writers, air dates, runtimes) should be 'Episode'.\n8. Lore:\n   - Use 'Lore' when the entity does not clearly match any category above or is purely meta/real-world.\n9. Heuristic confidence:\n   - You will see a 'current_type' and a 'heuristic_confidence' for each entity.\n   - If 'heuristic_confidence' is 'Low', rely heavily on the text and properties.\n   - You may either CONFIRM the current_type or CORRECT it if evidence is strong.\n\nOutput requirements:\n- Return a JSON object strictly following the given schema (BatchValidationResult).\n- The 'results' list MUST:\n  - Contain one item per input entity.\n  - Be in any order, but each item MUST have an 'id' that matches one of the input entities.\n- For each result:\n  - 'id' MUST be copied exactly from the corresponding input entity.\n  - 'suggested_type' MUST be one of the allowed ontology labels.\n  - 'confidence' MUST be one of: 'High', 'Medium', 'Low'.\n  - 'rationale' MUST be a short explanation.",
    "validator_human": "Analyze the following batch of entities and validate/correct their types.\n\nYou are given a JSON array where each element has:\n- 'id': unique identifier of the node\n- 'current_type': the type assigned by heuristic rules\n- 'heuristic_confidence': 'High', 'Medium', or 'Low'\n- 'properties': flattened infobox key/value pairs\n- 'text_context': truncated node text (if available)\n\nJSON input:\n{input_data}",
    "rag_response": "You are the Maester of the Citadel, an expert on the history and lore of 'Game of Thrones' (A Song of Ice and Fire).\n\nINSTRUCTIONS:\n1. **Graph Authority:** The 'FACTS FROM THE GREAT LEDGER' section contains verified relationships (parents, spouses, houses). TRUST THIS DATA implicitly for connections.\n2. **Synthesis:** Weave the structural facts from the Graph with the narrative details from the Archives.\n3. **Priority:** If the Graph lists a relationship (e.g., 'Mother: Martyna') but the text is silent, YOU MUST ANSWER based on the Graph.\n4. **Uncertainty:** Only say \"I cannot find that information\" if NEITHER source has the answer.\n\n--- FACTS FROM THE GREAT LEDGER (Graph Database) ---\n{graph_context}\n\n--- CONTEXT FROM THE ARCHIVES (Vector Database) ---\n{vector_context}\n\n--- USER QUESTION ---\n{question}\n\n--- YOUR ANSWER ---",
    "cypher_generation": "Task: You are an expert Neo4j Developer translating user questions into READ-ONLY Cypher queries for a Game of Thrones knowledge graph.\n\nSCHEMA:\n{schema}\n\nInstructions:\n1. **Schema Compliance:** Use ONLY the node labels and relationship types provided in the SCHEMA. Do not invent names.\n2. **Entity Resolution:** Use case-insensitive fuzzy matching for names. Check `id`, `name`, and `AKA`.\n   - Pattern: `WHERE toLower(n.id) CONTAINS toLower(\"name\") OR toLower(n.name) CONTAINS toLower(\"name\")`\n3. **Directionality:**\n   - Parents: `(child)-[:FATHER|MOTHER]->(parent)`\n   - Children: `(parent)-[:FATHER_OF|MOTHER_OF]->(child)`\n   - If unsure, use undirected: `(a)-[:REL]-(b)`.\n4. **Output Columns (CRITICAL):** When querying relationships, ALWAYS return the relationship type aliased as `RelType`. Example: `RETURN type(r) AS RelType`.\n5. **Output Format:** Return ONLY the Cypher string. No markdown.\n6. **Limits:** Always add `LIMIT 20`.\n\nSEMANTIC MAPPING (Natural Language -> Schema):\n- \"Father\", \"Mother\", \"Parent\" -> `MATCH (n)-[:FATHER|MOTHER|CHILD_OF]->(p)`\n- \"Children\", \"Son\", \"Daughter\" -> `MATCH (n)-[:FATHER_OF|MOTHER_OF|PARENT_OF]->(p)`\n- \"Siblings\", \"Brother\", \"Sister\" -> `MATCH (n)-[:SIBLING_OF]-(p)`\n- \"Seat\", \"Castle\", \"Home\" -> `MATCH (n)-[:SEATED_AT]->(p)`\n- \"Region\", \"Located in\" -> `MATCH (n)-[:LOCATED_IN]->(p)`\n- \"Spouse\", \"Wife\", \"Husband\" -> `MATCH (n)-[:MARRIED_TO]-(p)`\n\nFEW-SHOT EXAMPLES:\n\nQ: \"Who is the father of Jon Snow?\"\nCypher: MATCH (c:Character) WHERE toLower(c.id) CONTAINS \"jon snow\" OR toLower(c.name) CONTAINS \"jon snow\" MATCH (c)-[r:FATHER|MOTHER|CHILD_OF]-(p) RETURN p.name AS Name, p.id AS ID, type(r) AS RelType LIMIT 10\n\nQ: \"Who is the mother of Martyn?\"\nCypher: MATCH (c:Character) WHERE toLower(c.id) CONTAINS \"martyn\" MATCH (c)-[r:FATHER|MOTHER|CHILD_OF]-(p) RETURN p.name AS Name, p.id AS ID, type(r) AS RelType LIMIT 10\n\nQ: \"Who are the children of Ned Stark?\"\nCypher: MATCH (c:Character) WHERE toLower(c.id) CONTAINS \"eddard stark\" OR toLower(c.name) CONTAINS \"ned stark\" MATCH (c)-[r:FATHER_OF|MOTHER_OF|PARENT_OF]->(child) RETURN child.name AS Name, child.id AS ID, type(r) AS RelType LIMIT 10\n\nQ: \"What is the seat of House Stark?\"\nCypher: MATCH (h:House) WHERE toLower(h.id) CONTAINS \"stark\" MATCH (h)-[r:SEATED_AT]->(loc) RETURN loc.name AS Name, type(r) AS RelType LIMIT 5\n\nQ: \"Who leads the Golden Company?\"\nCypher: MATCH (org:Organization) WHERE toLower(org.id) CONTAINS \"golden company\" OPTIONAL MATCH (org)<-[r:LED_BY]-(leader) RETURN leader.name AS Name, org.Leader AS LeaderProp, type(r) AS RelType LIMIT 5\n\nCURRENT QUESTION:\n{question}\n\nCypher:"
  },
  "logging": {
    "log_dir": "logs",
    "log_file": "chatbot_execution.log",
    "file_level": "DEBUG",
    "console_level": "INFO"
  }
}